코드와 메모리 영역
(code and Memory Layout)

앞서 메모리 구조는
Text, Data, Heap, Stack으로 구분

Low address
Text
Data(정적변수, 전역변수)
Heap
Stack
High address

------------------------------------------

#include <studio.h>
#include <stdlib.h>

const int constval = 30;  //상수
int uninitial;
int initial = 30;
static int staticval = 70;

int function(){
    return 20;
}

int main(int argc, const char * argv[]){
    int localval1 = 30;  //지역변수 1
    int localval2;         //지역변수 2

    printf("숫자 입력 : ");
    scanf("%d", &localval2);

    char *arr = malloc(sizeof(char) * 10);

    return 0;
}


실제로 4개의 영역에 해당되는 
변수들의 메모리가 어떻게
할당되었는지를 검증

c, c++언어는 '포인터;란 개념이 있다
'메모리 주소를 가리키는 변수'라고 한다
해당 메모리 주소를 출력하는 방법은
%p을 쓰시면 된다.

위 코드에서 각각의 변수 및
함수들의 주소를 출력해보도록 하자
코드는 아래와 같다

동적으로 할당할 수 있는 함수는
Heap영역의 malloc함수으로 이동한다.


---------------------------------------

상수, 함수 -> Text
정역, 정적 변수 -> Data
지역변수 -> Stack
동적할당 -> Heap

malloc함수
-> 런타임(실행중)에 메모리를 동적으로
    할당할 수 있는 함수

-----------------------------------------

각각의 변수 및 함수들의 주소를 출력

const int constval = 30;
int initial = 30;
int localval1 = 30;

printf(" " , &constval)
printf(" ", &initial )
printf(" ", )

-> 코드, 시스템, 실행환경 등에 따라
   얼마든지 메모리주소는 달라질 수 있다.

중점적으로 봐야 할 점은
실제로 앞서 배웠던 메모리에
할당되는 위치와 같은 구조를 지니느냐

6. 상수
-> Text영역
-> 가장 낮은주소에 위치

1. 전역변수
-> 초기화된 변수
-> 초기화되지 않는 변수
-> Data 영역
2. 정적변수
-> Data 영역
3. 함수
-> Text영역
-> 함수안에 있는 변수는?
    Text영역에 있는 함수를 호출함과 동시
    내부에 있는 변수들은 Stack영역에
    할당하게 됩니다.
    // 해당 함수가 종료되면 Stack메모리
       있던 함수의 변수들은 모두 pop됨.
4. 지역변수
-> Stack영역
-> 다른 영역과는 다르게
    높은주소에서 낮은 주소로
    메모리에 할당된다.
-> 이를 확인하기 위해
    2개의 지역변수를 선언한다.
5. 동적할당 변수
-> Heap영역
-> Text, Data보다는 비교적 높은 주소에서
    시작하지만,
-> Stack영역에 비해서는
    한없이 작은 주소에서 
    시작하는 것을 볼 수 있습니다.

----------------------------------------------

포인터는 말 그대로 '시작 주소'
를 가리키는 때문에 
함수의 전체(구조)크기는
알기가 매우 힘듭니다.

두 함수가 인접한 메모리에 있다면 
대략이나마 유추는 가능하겟지만
정확히 알기는 어렵죠
그래서 별다른 박스는
해놓지 않았습니다.

1. uninitial
2. initial
3. static
4. function 
5. localval1 & localval2
6. 동적할당변수

----------------------------------------------
Buffer Overflow

버퍼(Buffer) + 넘치게(overflow)
-> Buffer는 보통 메모리를 의미
-> 또 다른 말로 Buffer Overrun

그 중 가장 대표적인 Heap과 Stack
-> 프로그램이 실행하면서
    생성되는 데이터들이 저장되는 공간

-> 해당 영역의 버퍼를 인위적으로 넘침.
-> 인접한 데이터 영역 +
    포인터 영역까지 침법
// 특정 명령을 넣어 프로그램을 
    붕괴시키거나 시스템의 권한을 상승
---------------------------------------------
Stack Overflow
-> 호출 스택이 할당 된 
    스택 영역 경계산 밖으로 넘어갈 때 발생
-> 가장 흔히 발생하는 경우는
    '재귀호출'에서 발생합니다.


이렇게 무한히 stack영역에 데이터가
push되다가 Stack영역을 넘어가버리게 되면
바로 Stack Overflow가 발생하는 것입니다

( 구체적으로 메모리에 어떻게 
  쌓이는지 보고싶은 분은
  아래 더보기를 
---------------------------------------------

Heap Overflow
-> Stack Overflow는 
힙 영역에서 할당된 영역의 경계선 밖으로
넘아갈 때 발생합니다.

OutOfMemory__[에러, 메모리 부족]

Heap영역보다 큰 데이터가 들어올 경우
Stack에서는 지역변수들이 스택에 쌓이면,
반대로 Heap영역에서는
동적으로 관리되는 데이터들이
일정 공간 이상 차지하게 될 경우 발생






















