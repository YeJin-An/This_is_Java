DS_DataStructure

Stack & queue
-------------------------------------------------------------
Stack
-> 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
-> 선형구조
-> 후입선출구조(LIFO : Last-In-First-Out)
     : 마지막에 삽입한 자료를 가장 먼저 꺼낸다.
-> 자료가 없을 때 pop하는 오류를 stack underflow
스택의 크기 이상의 자료를 push하려고 할때는 오류를 stack overflow
Stack st = new Stack( );


주요 연산
-> push : top을 위로 한칸 올리고, top이 가리키는 위치에 데이터 저장
-> pop  : top이 가리키는 데이터를 반환하고, top을 아래로 한칸 내린다.
-> peek : 스택의 top에 있는 item을 반환한다.
             pop과 달리 stack에서 객체를 꺼내지 않는다.

스택 용도
-> 연산자 후위표기법
-> 함수의 콜스택
     : LIFO구조 
     : 함수 호출이 발생하면 함수 수행에 필요한 정보를 
       스택 프레임에 저장하여 시스템 수택에 삽입한다.
-> 브라우저 뒤로가기
-> 문자열 역순 출력
-> DFS
----------------------------------------------------------------
Queue(선형 큐)
-> 큐의 뒤(rear)에서만 삽입 하고,
    큐의 앞(front)에서는 삭제만 이루어진다.
    FIFO(First-In-First-Out) : 가장 먼저 삽입된 원소가 가장 먼저 삭제
-> 자바에서 스택을 Stack클래스로 구현하여 제공하지만,
    Queue 인터페이스만 있고, 별도의 클래스가 없다.
    Queue 인터페이스를 구현한 클래스들을 사용해야 한다.
[Queue q = new LinkedList( );]

단점
-> 선형 큐의 삽입 및 삭제를 반복시 
    rear가 맨 마지막 인덱스를 가리키고 있어
    비어 있을 수 있지만, 꽉차 보일 수 있습니다.
-> 왜냐하면 index 단위로 Queue의 연산을 진행했기 때문이다.
    그리고 이러한 점이 문제점이 될 수 있습니다.

// 이러한 단점을 보완하기 위해서 Circular Queue(원형 큐)가 생겨남.
--------------------------------------------------------------------

circular Queue(원형 큐) 용도
-> Buffer : 데이터를 전송하는 동안 일시적으로 
              그 데이터를 보관하는 메모리의 영역
              (입출력 및 네트워크에서 사용)
-> BFS
-> 작업 스케쥴링

[주요 연산]
-> enQueue : 삽입, 메소드 in Java : offer( )
-> deQueue : 삭제, 메소드 in Java : poll( )

[설명]
-> 일차원 배열을 사용하여 구현
-> 초기 front와 rear는 맨 처음 인덱스에 위치한다.
-> front와 rear를 회전을 위해 묘듈러(%)연산을 사용. 
--------------------------------------------------------------------

구현방법은 3가지존재
1) 배열을 기반으로 구현하는 방법
2) 연결 리스트를 기반으로 구현하는 방법
3) 힙(heap)을 이용하는 방법

우선순위 큐는 배열이나 연결리스트로 구현하지 않을까?
-> 배열이나 연결리스트로 구현할 경우 간단하게 구현이 가능하지만,
    데이터 삽입과 과정 밀고당기는 연산을 계속 하여야 함.
-> 삽입의 위치를 찾기 위해 배열에 저장된 
    모든 데이터와 우선순위를 비교해야 함.
-> 연결리스트의 경우, 첫번째 노드부터 시작해 마지막 노드에
    저장된 데이터와 우선순위 비교를 진행해야 할 수 있음 -> {성능저하}
// 그래서 일반적으로 힙을 이용해 구현한다.
------------------------------------------------------------------------
Deque
-> 자료의 추가와 삭제를 양쪽 끝에서 가능하게 하는 자료구조
-> 큐와 스택을 합친 형태로 생각할 수 있음
-> 연속적인 메모리를 기반으로 하는 '시퀀스 컨테이너'
    다라서, 임의 접근 반복자 제공.

Deque의 응용
-> 스케줄링 : 스케줄링이 복잡해질수록 
                  스택과 덱보다 효율이 잘 나오는 경우가 있음.
-> 우선순위 조절 : 한방향으로만 삽입/삭제가 가능한 스택과 큐와 달리
                        양방향으로 삽입 삭제가 자유롭기 때문이다.

유형
-> scroll : 입력 제한 덱, 입력이 한쪽에서만 일어나도록 제한
->   self : 출력 제한 덱, 출력이 한쪽에서만 이러나도록 제한
















