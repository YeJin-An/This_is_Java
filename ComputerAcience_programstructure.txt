컴퓨터 공학 개론 __ 프로그래밍 언어와 소프트웨어 공학

소스프로그램 -> 어휘분석기 
--(토큰)-> 구문 분석기 
--(구문 분석트리)-> 코드 생성기 
-> 목적 프로그램

---------------------------------------------------------------------------------------------
1. 프로그래밍 언어

1-1.역사적 고찰
-> 1세대 언어 '기계어'
-> 2세대 언어 '어셈블리 언어'
-> 3세대 언어 '프로그래밍 언어'
// 사람이 특성에 맞추어야 하는 환경에서 문제를 해결
   -> 컴퓨터가 사람의 특성에 맞추어진 환경헤서 문제를 해결
 
1-2. 언어의 구현 : 번역 과정
-> 소스 프로그램 : 원래 형태의 프로그램
-> 목적 프로그램 : 번역된 버전

	번역 과정 세가지
	1. 어휘 분석기 -> [소스 프로그램(단어)]토큰(token)을 표현하는 기호열을 인식하는 과정
	2. 구문 분석기 -> 토큰들을 문장으로 구문 다이어그램을 통해 구문 분석 트리를 생성
	3. 코드 생성기 -> 구문 분석기가 인식한 문장을 구현하기 위해 기계어 명령을 생성하는 단계

============================================================

1-3. 객체지향 프로그래밍

1. 객체(object) : 데이터와 [프로시저]를 포함하는 [능동적] 프로그램 단위
Q. 객체의 구성 요소?
-> 인스턴스 변수 ( instance variable )  : 객체 안에 들어있는 [변수]로 객체 내부의 {정보 저장}
-> 메서드 ( method )                      : 객체 안의 [함수(프로시저)]
-> 생성자 ( constructor )                  : 객체의 초기화에 사용되는 특별한 메서드
// 클래스( class ) --> OOP에서 객체들을 위한 틀 ( template )

2. 상속(inheritance)
-> 다른 특성을 갖는 객체들의 기술을 쉽게 사용할 수 있게 하는 것
-> 새로운 클래스 안에 정의 되어 있는 클래스를 사용하여 정의할 수 있음.
-> 객체 지향 언언들은 상속이라고 불리는 기법을 사용한다.

3. 다형성(polymorphism)
-> 객체마다 메세지를 자신에 맞게 해석하는 것을 '다형적'이라고 한다.
-> 메서드 호출이 적용 개체에 따라 달리 해석이 된다.

4. 캡슐화(encapsulation)
-> 객체의 내부 속석에 대한 접근을 제한하는 것
-> 객체의 어떤 속성이 캡슐화되어 있다는 것은 오직 객체 자체에서만 접근할 수 있다는 것
    이러한 속성을 전용( private ) 속성이라고 한다.
    반면 외부에서 접근이 가능한 속성은 공용( public ) 속성이라고 합니다.

============================================================

1-4. 병행활동 프로그래밍

1. 병렬(parallel) 또는 병행 ( concurrent )
-> 여러 프로세스를 동시에 실행하는 것
-> 각 활성화(프로세스)에 한 개씩 여러개의 CPU 코어가 필요하다!!
-> CPU가 하나만 있는 경우, 시분할 방식(단일 프로세서의 시간을 나누어 쓴다)을 이용.

2. 모니터 ( monitor )
-> 자신에 대한 접근 제어 능력을 갖춘 데이터 항목

Q. monitor가 왜 존재하는 것일까요?
우선 상호 배제(Mutual Exclusion)란 ? -> 한 번에 한 프로세스만이 데이터에 접근하는 것.
공유 데이터에 접근하는 각각의 프로그램의 단위는 (한번에 한 프로세스만 데이터에 접근하도록)
적절히 설계되어야 하는데, 
한 부분이라도 잘못 설계가 될 경우, 모두에세 피해(문제)가 발생(생김)합니다.
// 따라서 [데이터 항목 자제]가 스스로 접근 제어 능력을 가지는 것이 더 나은 해결책이고,
   이러한 능력을 가진 항목이 '모니터'라고 합니다.

-----------------------------------------------------------------------------------------------

2. 소프트웨어 공학

2-1. 소프트웨어 생명주기의 개발 단계
-> 1) 요구사항 분석 -> 2) 설계 -> 3) 구현 -> 4) 테스트

2-2. 소프트웨어 공학 방법론
-> 초창기에는 개발 단계를 순차적으로 수행할 것을 주장했지만,
    개발을 진행하면서 허용되는 범위가 넓어져 위험을 따른다고 한다.
-> 따라서 엔지니어들이 구현을 하기 전에 [설계의 중요성]을 주장했고,
    이러한 과정을 거쳐 나온 것은 "폭포수 모델" 입니다.

  : 목포수 모델 -> 개발 과정이 한 방향으로만 이루어지는 것.
--> 최근 "자유분방한" 시행착오의 과정으로 모순을 극복하는 방향으로 진행이 되고 있고,
     이러한 과정을 거쳐 나온것은 "전진적 모델"입니다.
  
  :    점진적 모델  -> Prototyping(프로토타입) 이라는 소프트웨어 개발 방식을 이용하는데,
                       -> Prototyping(프로토타입) 이라는 제안 시스템의 미완성 버전을 구축하고 평가한다.
  : vs 반복형 모델  -> 최종 설계를 구현하면서 Prototyping을 버리는 폐기형 Prototyping방식을 활용.

  :  공개소스 개발  -> 점진적 of 반복형 of 비정형적 변형 of ONE 컴퓨터 전문가들 사이에 잘 알려져 있는 방식
                       -> 무료 소프트웨어의 많은 수가 이방식으로 개발된다 EX>Linux OS   

  :    기민성 방법  -> 폭포수 모델과 가장 많은 차이가 나는 방법
                       -> EX> XP(eXtreme Programing)
                       -> 10명 이내의 개발자로 이루어진 팀이 
                           자유롭게 생각을 나누고 서로를 돕는 방식으로 개발합니다.

                       -> 기민성 방법의 중요한 키워드 "유연성"이다.
                       -> 프로그래머와 관리자들의 소프트웨어 개발 업무 중에
                           각자 자신이 맞은 일을 독립적으로 수행하는 폭포수 모델과는 대조적이다. 
                       

2-3. 모듈화
 : 괸리하기 위한 소프트웨어를 만드는 방법!

-- 모듈간의 결합도
  : 제어 결합     --> 함수 호출처럼 한 모듈이 다른 모듈에게 [실행 제어]를 넘길 대 발생.
  : 데이터 결합  --> 모듈 사이의 데이터 공유
                    --> 두 모듈이 동일한 데이터 항목을 사용할 경우 
                         한 모듈의 변경은 다른 모듈에도 영향을 미칠 수 있다.

-- 모듈의 응집도
  : 논리적 응집도 --> 약한 형태의 응집도
                      --> 모듈 내부의 요소들은 [논리적으로 비슷한 활동]을 수행하는 것에서 도출
  : 기능적 응집도 --> 강한 형태의 응집도
                      --> 모듈 안의 모든 부분은 [한가지 수행에 초점]을 맞추어야 함을 의미
--------------------------------------------------------------------------------------------------

3. 소프트웨어의 품질 보증

3-1. 유리박스 테스트
-> 소프트웨어를 테스트하는 사람이 
    소프트웨어의 내부 구조를 잘 알고 있을 경우 사용한다.
EX 1> 파레토(Pareto)원리
-> 특정 부분에 집중하여 문제를 찾는 것!
-> 소프트웨어 상의 오류는 모여서 나타나는 경향이 있다는 것을 활용하는 것이다.
EX 2> 기초 경로 테스트(Basis path testing)
-> 소프트웨어 안의 모든 명령이 적어도 한 번씩 실행되도록
    보당하는 테스트 데이터 집합을 개발 하는 것이다.

3-2. 블랙박스 테스트
-> 유리박스 테스트와 대조 되며, 
    소프트웨어 내부 구성에 대한 지식에 의존하지 않는 테스트
-> 사용자의 관점에서 수행되고, 적확성과 시간을 기준으로 형가한다.
EX> 경계값 분석, 중복성 테스트, 베타 테스트


















